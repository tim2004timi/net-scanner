from typing import List

from fastapi import APIRouter, HTTPException
from fastapi.params import Depends
from fastapi.security import HTTPBearer
from sqlalchemy.ext.asyncio import AsyncSession

from .service import get_vulnerability_scan_by_id
from ..assets.service import get_asset_by_id
from ..database import db_manager, redis_client
from . import service
from ..auth.dependencies import get_current_active_auth_user
from ..dependencies import check_permission, Permission
from ..users.schemas import User
from .schemas import (
    VulnerabilityScan,
    VulnerabilityScanList,
    VulnerabilityScanCreate,
    ScanStatusEnum,
    CVEList,
    CVE,
    CVECreate,
    CVEFromService,
)

http_bearer = HTTPBearer(auto_error=False)
router = APIRouter(
    tags=["Vulnerability Scans"],
    prefix="/vulnerability-scans",
    dependencies=[
        Depends(http_bearer),
        # Depends(check_permission(Permission.USER)),
    ],
)


@router.get(
    path="/",
    response_model=VulnerabilityScanList,
    summary="Get vulnerability scans for current user",
)
async def get_vulnerability_scans_by_user(
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
    page_size: int = 10,
    page_number: int = 1,
    search: str | None = None,
    status: ScanStatusEnum | None = None,
):
    """
    Gets vulnerability scans list for current authenticated user

    - **access_token**: Header bearer access token (required)
    """
    return await service.get_vulnerability_scans_by_user(
        session=session,
        user=user,
        page_size=page_size,
        page_number=page_number,
        status_filter=status,
        search=search,
    )


@router.post(
    path="/",
    response_model=VulnerabilityScan,
    summary="Create vulnerability scan for current user",
)
async def create_vulnerability_scan(
    asset_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Creates a vulnerability scan for current authenticated user and run hosts scan.

    - **access_token**: Header bearer access token (required)

    - **name**: Name of the asset (required, unique)
    - **type**: Type of the asset (default="Внешний", values: "Внешний", "Внутренний")
    - **targets**: List of asset targets (required, e.g. 10.0.0.1, 10.0.0.1/24, domain.ru)
    - **frequency**: Frequency of scanning (default="Один раз", values: "Один раз", "Ежедневно", "Еженедельно", "Ежемесячно")
    - **tg_alerts**: Confirm alerts to telegram (default=false)
    """
    asset = await get_asset_by_id(session=session, user=user, asset_id=asset_id)
    return await service.create_vulnerability_scan(
        session=session,
        user=user,
        asset=asset,
    )


@router.delete(
    path="/{vulnerability_scan_id}/",
    response_model=VulnerabilityScan,
    summary="Delete vulnerability scan for current user",
)
async def delete_vulnerability_scan(
    vulnerability_scan_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Deletes a vulnerability scan for current authenticated user

    - **access_token**: Header bearer access token (required)
    """
    vulnerability_scan = await service.get_vulnerability_scan_by_id(
        session=session, user=user, vulnerability_scan_id=vulnerability_scan_id
    )
    return await service.delete_vulnerability_scan(
        session=session,
        vulnerability_scan=vulnerability_scan,
    )


router2 = APIRouter(
    tags=["CVEs"],
    prefix="/vulnerability-scans",
    dependencies=[
        Depends(http_bearer),
        # Depends(check_permission(Permission.USER)),
    ],
)


@router2.get(
    path="/{scan_id}/cves/",
    response_model=CVEList,
    summary="Get cves by scan",
)
async def get_cves_by_scan_id(
    scan_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
    page_size: int = 10,
    page_number: int = 1,
    search: str | None = None,
):
    """
    Gets cves list by scan ID for current authenticated user

    - **access_token**: Header bearer access token (required)
    """
    scan = await get_vulnerability_scan_by_id(
        vulnerability_scan_id=scan_id, session=session, user=user
    )
    return await service.get_cve_by_scan(
        session=session,
        user=user,
        page_size=page_size,
        page_number=page_number,
        search=search,
        scan=scan,
    )


@router2.get(
    path="/vulnerability-scans/{cve_id}/",
    response_model=CVE,
    summary="Get cve by id for current user",
)
async def get_host_scan_by_id(
    cve_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Gets cve by id for current authenticated user

    - **access_token**: Header bearer access token (required)
    """
    return await service.get_cve_by_id(session=session, user=user, cve_id=cve_id)


@router2.post(
    path="/{scan_id}/cves/",
    summary="Create cves list for scan for scan service",
    dependencies=[Depends(check_permission(Permission.ADMIN))],
)
async def create_cves(
    scan_id: int,
    cves_list_create: List[CVECreate],
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Creates cves.
    Endpoint only for scaner services.

    - **access_token**: Header bearer access token (required)
    """
    scan = await get_vulnerability_scan_by_id(
        session=session, vulnerability_scan_id=scan_id, user=None
    )
    try:
        await service.create_cves(
            session=session,
            user_id=scan.user_id,
            cves_list_create=cves_list_create,
            scan=scan,
        )
    except ValueError:
        raise HTTPException(
            status_code=400, detail="Ответ не сохранился, т.к. скан CVE провален"
        )
    return {"message": "OK"}


@router2.post(
    path="/{scan_id}/cves/keep-alive/",
    summary="Keep alive for cve for scan service",
    dependencies=[Depends(check_permission(Permission.ADMIN))],
)
async def keep_alive_cves(
    scan_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    _: User = Depends(get_current_active_auth_user),
):
    """
    Keep alive for cve scan for scan service every 5 minutes.
    If there isn`t request for 11 minutes that status is Failed.
    Endpoint only for scaner services.

    - **access_token**: Header bearer access token (required)
    """
    # Проверяем, существует ли актив
    scan = await session.get(VulnerabilityScan, scan_id)
    if not scan:
        raise HTTPException(status_code=404, detail="Ресурс не найден")

    # Обновляем время последнего keep-alive в Redis с TTL 11 секунд
    key = f"vulnerability_scan:{scan.id}:keep_alive"
    await redis_client.set(key, 1, ex=11)

    return {"message": "Keep-alive signal received"}


@router2.delete(
    path="/cves/{cve_id}/",
    response_model=CVE,
    summary="Delete cve for current user",
)
async def delete_cve(
    cve_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Deletes cve for current authenticated user

    - **access_token**: Header bearer access token (required)
    """
    cve = await service.get_cve_by_id(session=session, user=user, cve_id=cve_id)
    return await service.delete_cve(
        session=session,
        cve=cve,
    )


@router2.post(
    path="/{scan_id}/cves/",
    summary="Create cves list for scan for scan service",
    dependencies=[Depends(check_permission(Permission.ADMIN))],
)
async def create_cves(
    scan_id: int,
    cves_list_create: List[CVEFromService],
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Creates cves.
    Endpoint only for scaner services.

    - **access_token**: Header bearer access token (required)
    """
    scan = await get_vulnerability_scan_by_id(
        session=session, vulnerability_scan_id=scan_id, user=None
    )
    cves_list_create = list(map(convert_to_cve_create, cves_list_create))
    try:
        await service.create_cves(
            session=session,
            user_id=scan.user_id,
            cves_list_create=cves_list_create,
            scan=scan,
        )
    except ValueError:
        raise HTTPException(
            status_code=400, detail="Ответ не сохранился, т.к. скан CVE провален"
        )
    return {"message": "OK"}


@router2.get(
    path="/{cve_id}/ai/",
    summary="Get ai answer by id cve for current user",
)
async def get_ai_answer_by_cve_id(
    cve_id: int,
    session: AsyncSession = Depends(db_manager.session_dependency),
    user: User = Depends(get_current_active_auth_user),
):
    """
    Gets AI answer by cve id for current authenticated user

    - **access_token**: Header bearer access token (required)
    """
    return await service.get_ai_by_cve_id(session=session, user=user, cve_id=cve_id)


def convert_to_cve_create(cve: CVEFromService) -> CVECreate:
    has_exploit = bool(cve.exploits)

    return CVECreate(
        name=cve.cve_identifier,
        severity=cve.cvss,
        title=f"{cve.service} (port {cve.port})",
        exploit=has_exploit,
        description=cve.description,
        ip=cve.ip,
        service=cve.service,  # Используем текстовое представление Protocol
        port=cve.port,
        ai_answer=None,  # AI-ответ оставляем пустым
    )
