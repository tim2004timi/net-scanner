import logging
from datetime import datetime
from typing import List

import httpx
from fastapi import HTTPException
from sqlalchemy import select, Result
from sqlalchemy.ext.asyncio import AsyncSession
from starlette import status

from math import ceil
from .models import Asset, VulnerabilityScan, CVE
from .schemas import ScanStatusEnum, VulnerabilityScanList, VulnerabilityScanCreate
from ..config import VULNERABILITY_SCAN_SERVICE_URL
from ..database import db_manager, redis_client
from ..host_scans.models import HostScan
from ..host_scans.service import get_host_scans_by_asset
from ..scheduler_utils import remove_scheduled_scan, schedule_scan
from ..users import User


logger = logging.getLogger("app")


async def get_vulnerability_scan_by_id(
    session: AsyncSession, user: User | None, vulnerability_scan_id: int
) -> VulnerabilityScan:
    vulnerability_scan = await session.get(VulnerabilityScan, vulnerability_scan_id)
    if not vulnerability_scan:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Ресурс с ID ({vulnerability_scan_id}) не найден",
        )
    if user and vulnerability_scan.user_id != user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Ресурс не принадлежит пользователю",
        )
    return vulnerability_scan


async def get_vulnerability_scans_by_user(
    session: AsyncSession,
    user: User,
    page_size: int = 10,
    page_number: int = 1,
    search: str | None = None,
    status_filter: ScanStatusEnum | None = None,
) -> VulnerabilityScanList:
    # Список всех сканов на уязвимость
    stmt = (
        select(VulnerabilityScan)
        .where(VulnerabilityScan.user_id == user.id)
        .order_by(VulnerabilityScan.id.desc())
    )
    if status_filter is not None:
        stmt = stmt.where(VulnerabilityScan.status == status_filter)
    if search is not None:
        search = f"%{search}%"
        stmt = stmt.where(VulnerabilityScan.asset_name.like(search))
    result: Result = await session.execute(stmt)
    vulnerability_scans = list(result.scalars().all())

    # Кол-во уникальных CVE-шек
    critical, high, medium, low, unknown = 0, 0, 0, 0, 0
    stmt = select(CVE).where(CVE.user_id == user.id)
    result: Result = await session.execute(stmt)
    cves: list[CVE] = list(result.scalars().all())
    cves_set = set()
    for cve in cves:
        if cve not in cves_set:
            if cve.severity == 0:
                unknown += 1
            elif 0 < cve.severity < 4:
                low += 1
            elif 4 <= cve.severity < 7:
                medium += 1
            elif 7 <= cve.severity < 9:
                high += 1
            elif 9 <= cve.severity <= 10:
                critical += 1
        cves_set.add(cve.name)

    limit = page_size
    offset = (page_number - 1) * page_size
    response_vulnerability_scans = vulnerability_scans[offset : offset + limit]
    total_pages = ceil(len(vulnerability_scans) / page_size)
    vulnerability_scans_list = VulnerabilityScanList(
        vulnerability_scans=response_vulnerability_scans,
        total_pages=total_pages,
        current_page=page_number,
        total_cves=len(cves_set),
        critical_cves=critical,
        high_cves=high,
        medium_cves=medium,
        low_cves=low,
        unknown_cves=unknown,
    )
    return vulnerability_scans_list


async def create_vulnerability_scan(
    session: AsyncSession,
    user: User,
    asset: Asset,
    vulnerability_scan_create: VulnerabilityScanCreate,
) -> VulnerabilityScan:

    vulnerability_scan = VulnerabilityScan(
        **vulnerability_scan_create.model_dump(),
        user_id=user.id,
        asset_id=asset.id,
        asset_name=asset.name,
        status=ScanStatusEnum.IN_PROCESS,
    )
    session.add(vulnerability_scan)
    await session.flush()
    key = f"vulnerability_scan:{vulnerability_scan.id}:keep_alive"
    await redis_client.set(key, 1, ex=11)
    logger.info("Added asset to redis for keep-alive")
    await session.commit()
    await session.refresh(vulnerability_scan)

    host_scan_list = await get_host_scans_by_asset(
        session=session, user=user, asset=asset
    )
    host_scans = host_scan_list.host_scans
    ips_set = set()
    for host_scan in host_scans:
        for ip in host_scan.ips:
            ips_set.add(ip)
    try:
        await send_to_scan_service(
            vulnerability_scan=vulnerability_scan, ips=list(ips_set), session=session
        )
        vulnerability_scan.start_host_scan_at = datetime.utcnow()
    except Exception as e:
        vulnerability_scan.status = ScanStatusEnum.FAILED
        await session.commit()
        await session.refresh(vulnerability_scan)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Не удалось отправить задачу сканеру",
        )
    return vulnerability_scan


async def delete_vulnerability_scan(
    session: AsyncSession, vulnerability_scan: VulnerabilityScan
) -> VulnerabilityScan:
    await session.delete(vulnerability_scan)
    await session.commit()
    return vulnerability_scan


async def send_to_scan_service(
    vulnerability_scan: VulnerabilityScan,
    session: AsyncSession,
    ips: List[str],
    timeout=1,
):
    async with httpx.AsyncClient(timeout=timeout) as client:
        data = {
            "vulnerability_scan_id": vulnerability_scan.id,
            "ips": ips,
        }
        try:
            response = await client.post(VULNERABILITY_SCAN_SERVICE_URL, json=data)
            vulnerability_scan.start_host_scan_at = datetime.utcnow()
            await session.commit()
            response.raise_for_status()
        except Exception as e:
            logger.info(f"Не удалось отправить vulnerability_scan на сканирование")
