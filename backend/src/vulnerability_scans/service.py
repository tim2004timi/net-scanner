import logging
from datetime import datetime
from typing import List

import httpx
from pydantic import parse_obj_as

from fastapi import HTTPException
from sqlalchemy import select, Result
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from starlette import status

from math import ceil

from . import schemas
from .models import Asset, VulnerabilityScan, CVE
from .schemas import ScanStatusEnum, VulnerabilityScanList, VulnerabilityScanCreate
from ..config import VULNERABILITY_SCAN_SERVICE_URL
from ..database import db_manager, redis_client
from ..host_scans.models import HostScan
from ..host_scans.service import get_host_scans_by_asset
from ..scheduler_utils import remove_scheduled_scan, schedule_scan
from ..users import User


logger = logging.getLogger("app")


async def get_vulnerability_scan_by_id(
    session: AsyncSession, user: User | None, vulnerability_scan_id: int
) -> VulnerabilityScan:
    vulnerability_scan = await session.get(VulnerabilityScan, vulnerability_scan_id)
    if not vulnerability_scan:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Ресурс с ID ({vulnerability_scan_id}) не найден",
        )
    if user and vulnerability_scan.user_id != user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Ресурс не принадлежит пользователю",
        )
    return vulnerability_scan


async def get_vulnerability_scans_by_user(
    session: AsyncSession,
    user: User,
    page_size: int = 10,
    page_number: int = 1,
    search: str | None = None,
    status_filter: ScanStatusEnum | None = None,
) -> VulnerabilityScanList:
    # Список всех сканов на уязвимость
    stmt = (
        select(VulnerabilityScan)
        .options(selectinload(VulnerabilityScan.cves))
        .where(VulnerabilityScan.user_id == user.id)
        .order_by(VulnerabilityScan.id.desc())
    )
    if status_filter is not None:
        stmt = stmt.where(VulnerabilityScan.status == status_filter)
    if search is not None:
        search = f"%{search}%"
        stmt = stmt.where(VulnerabilityScan.asset_name.like(search))
    result: Result = await session.execute(stmt)
    vulnerability_scans = result.scalars().all()
    vulnerability_scans = parse_obj_as(
        List[schemas.VulnerabilityScan], vulnerability_scans
    )

    # Подсчет общей критичности
    for vulnerability in vulnerability_scans:
        critical, high, medium, low, unknown = 0, 0, 0, 0, 0
        for cve in vulnerability.cves:
            if cve.severity == 0:
                unknown += 1
            elif 0 < cve.severity < 4:
                low += 1
            elif 4 <= cve.severity < 7:
                medium += 1
            elif 7 <= cve.severity < 9:
                high += 1
            elif 9 <= cve.severity <= 10:
                critical += 1
        threat_level_value = max(critical, high, medium, low, unknown)
        threat_level_index = (critical, high, medium, low, unknown).index(
            threat_level_value
        )
        if threat_level_index == 0:
            vulnerability.threat_level = "Критический"
        if threat_level_index == 1:
            vulnerability.threat_level = "Высокий"
        if threat_level_index == 2:
            vulnerability.threat_level = "Средний"
        if threat_level_index == 3:
            vulnerability.threat_level = "Низкий"
        if threat_level_index == 4:
            vulnerability.threat_level = "Неизвестно"

    # Кол-во уникальных CVE-шек
    critical, high, medium, low, unknown = 0, 0, 0, 0, 0
    stmt = select(CVE).where(CVE.user_id == user.id)
    result: Result = await session.execute(stmt)
    cves: list[CVE] = list(result.scalars().all())
    cves_set = set()
    for cve in cves:
        if cve not in cves_set:
            if cve.severity == 0:
                unknown += 1
            elif 0 < cve.severity < 4:
                low += 1
            elif 4 <= cve.severity < 7:
                medium += 1
            elif 7 <= cve.severity < 9:
                high += 1
            elif 9 <= cve.severity <= 10:
                critical += 1
        cves_set.add(cve.name)

    limit = page_size
    offset = (page_number - 1) * page_size
    response_vulnerability_scans = vulnerability_scans[offset : offset + limit]
    total_pages = ceil(len(vulnerability_scans) / page_size)
    vulnerability_scans_list = VulnerabilityScanList(
        vulnerability_scans=response_vulnerability_scans,
        total_pages=total_pages,
        current_page=page_number,
        total_cves=len(cves_set),
        critical_cves=critical,
        high_cves=high,
        medium_cves=medium,
        low_cves=low,
        unknown_cves=unknown,
    )
    return vulnerability_scans_list


async def create_vulnerability_scan(
    session: AsyncSession,
    user: User,
    asset: Asset,
) -> VulnerabilityScan:

    vulnerability_scan = VulnerabilityScan(
        user_id=user.id,
        asset_id=asset.id,
        asset_name=asset.name,
        status=ScanStatusEnum.IN_PROCESS,
    )
    session.add(vulnerability_scan)
    await session.flush()
    key = f"vulnerability_scan:{vulnerability_scan.id}:keep_alive"
    await redis_client.set(key, 1, ex=11)
    logger.info("Added asset to redis for keep-alive")
    await session.commit()
    await session.refresh(vulnerability_scan)

    host_scan_list = await get_host_scans_by_asset(
        session=session, user=user, asset=asset
    )
    host_scans = host_scan_list.host_scans
    ips_set = set()
    for host_scan in host_scans:
        for ip in host_scan.ips:
            ips_set.add(ip)
    try:
        await send_to_scan_service(
            vulnerability_scan=vulnerability_scan, ips=list(ips_set), session=session
        )
        vulnerability_scan.start_host_scan_at = datetime.utcnow()
    except Exception as e:
        vulnerability_scan.status = ScanStatusEnum.FAILED
        await session.commit()
        await session.refresh(vulnerability_scan)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Не удалось отправить задачу сканеру",
        )
    return vulnerability_scan


async def delete_vulnerability_scan(
    session: AsyncSession, vulnerability_scan: VulnerabilityScan
) -> VulnerabilityScan:
    await session.delete(vulnerability_scan)
    await session.commit()
    return vulnerability_scan


async def send_to_scan_service(
    vulnerability_scan: VulnerabilityScan,
    session: AsyncSession,
    ips: List[str],
    timeout=1,
):
    async with httpx.AsyncClient(timeout=timeout) as client:
        data = {
            "vulnerability_scan_id": vulnerability_scan.id,
            "ips": ips,
        }
        try:
            response = await client.post(VULNERABILITY_SCAN_SERVICE_URL, json=data)
            vulnerability_scan.start_host_scan_at = datetime.utcnow()
            await session.commit()
            response.raise_for_status()
        except Exception as e:
            logger.info(f"Не удалось отправить vulnerability_scan на сканирование")


async def get_cve_by_id(
    session: AsyncSession, user: User, vulnerability_scan_id: int
) -> HostScan:
    host_scan = await session.get(HostScan, host_scan_id)
    if not host_scan:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Сканирование хоста с ID ({host_scan_id}) не найдено",
        )
    if host_scan.user_id != user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Сканирование хоста не принадлежит пользователю",
        )
    return host_scan
