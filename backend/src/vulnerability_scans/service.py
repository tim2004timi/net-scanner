import logging
from datetime import datetime
from typing import List

import httpx
from httpx import TimeoutException, RequestError
from pydantic import parse_obj_as

from fastapi import HTTPException
from sqlalchemy import select, Result, or_, func, delete, insert
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from starlette import status

from math import ceil

from . import schemas
from .models import Asset, VulnerabilityScan, CVE
from .schemas import (
    ScanStatusEnum,
    VulnerabilityScanList,
    VulnerabilityScanCreate,
    CVEList,
    CVECreate,
)
from ..config import settings
from ..database import db_manager, redis_client
from ..host_scans.service import get_host_scans_by_asset
from ..users import User


logger = logging.getLogger("app")


async def get_vulnerability_scan_by_id(
    session: AsyncSession, user: User | None, vulnerability_scan_id: int
) -> VulnerabilityScan:
    vulnerability_scan = await session.get(VulnerabilityScan, vulnerability_scan_id)
    if not vulnerability_scan:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Ресурс с ID ({vulnerability_scan_id}) не найден",
        )
    if user and vulnerability_scan.user_id != user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Ресурс не принадлежит пользователю",
        )
    return vulnerability_scan


async def get_vulnerability_scans_by_user(
    session: AsyncSession,
    user: User,
    page_size: int = 10,
    page_number: int = 1,
    search: str | None = None,
    status_filter: ScanStatusEnum | None = None,
) -> VulnerabilityScanList:
    # Список всех сканов на уязвимость
    stmt = (
        select(VulnerabilityScan)
        .options(selectinload(VulnerabilityScan.cves))
        .where(VulnerabilityScan.user_id == user.id)
        .order_by(VulnerabilityScan.id.desc())
    )
    if status_filter is not None:
        stmt = stmt.where(VulnerabilityScan.status == status_filter)
    if search is not None:
        search = f"%{search}%"
        stmt = stmt.where(VulnerabilityScan.asset_name.like(search))
    result: Result = await session.execute(stmt)
    vulnerability_scans = result.scalars().all()
    vulnerability_scans_schema = parse_obj_as(
        List[schemas.VulnerabilityScan], vulnerability_scans
    )

    # Подсчет общей критичности
    for i in range(len(vulnerability_scans)):
        critical, high, medium, low, unknown = 0, 0, 0, 0, 0
        for cve in vulnerability_scans[i].cves:
            if cve.severity == 0:
                unknown += 1
            elif 0 < cve.severity < 4:
                low += 1
            elif 4 <= cve.severity < 7:
                medium += 1
            elif 7 <= cve.severity < 9:
                high += 1
            elif 9 <= cve.severity <= 10:
                critical += 1
        threat_level_value = max(critical, high, medium, low, unknown)
        threat_level_index = (critical, high, medium, low, unknown).index(
            threat_level_value
        )
        if threat_level_index == 0:
            vulnerability_scans_schema[i].threat_level = "Критический"
        if threat_level_index == 1:
            vulnerability_scans_schema[i].threat_level = "Высокий"
        if threat_level_index == 2:
            vulnerability_scans_schema[i].threat_level = "Средний"
        if threat_level_index == 3:
            vulnerability_scans_schema[i].threat_level = "Низкий"
        if threat_level_index == 4:
            vulnerability_scans_schema[i].threat_level = "Неизвестно"

    # Кол-во уникальных CVE-шек
    critical, high, medium, low, unknown = 0, 0, 0, 0, 0
    stmt = select(CVE).where(CVE.user_id == user.id)
    result: Result = await session.execute(stmt)
    cves: list[CVE] = list(result.scalars().all())
    cves_set = set()
    for cve in cves:
        if cve not in cves_set:
            if cve.severity == 0:
                unknown += 1
            elif 0 < cve.severity < 4:
                low += 1
            elif 4 <= cve.severity < 7:
                medium += 1
            elif 7 <= cve.severity < 9:
                high += 1
            elif 9 <= cve.severity <= 10:
                critical += 1
        cves_set.add(cve.name)

    limit = page_size
    offset = (page_number - 1) * page_size
    response_vulnerability_scans = vulnerability_scans_schema[offset : offset + limit]
    total_pages = ceil(len(vulnerability_scans_schema) / page_size)
    vulnerability_scans_list = VulnerabilityScanList(
        vulnerability_scans=response_vulnerability_scans,
        total_pages=total_pages,
        current_page=page_number,
        total_cves=len(cves_set),
        critical_cves=critical,
        high_cves=high,
        medium_cves=medium,
        low_cves=low,
        unknown_cves=unknown,
    )
    return vulnerability_scans_list


async def create_vulnerability_scan(
    session: AsyncSession,
    user: User,
    asset: Asset,
) -> VulnerabilityScan:

    vulnerability_scan = VulnerabilityScan(
        user_id=user.id,
        asset_id=asset.id,
        asset_name=asset.name,
        status=ScanStatusEnum.IN_PROCESS,
    )
    session.add(vulnerability_scan)
    await session.flush()
    key = f"vulnerability_scan:{vulnerability_scan.id}:keep_alive"
    await redis_client.set(key, 1, ex=11)
    logger.info("Added asset to redis for keep-alive")
    await session.commit()
    await session.refresh(vulnerability_scan)

    host_scan_list = await get_host_scans_by_asset(
        session=session, user=user, asset=asset
    )
    host_scans = host_scan_list.host_scans
    ips_set = set()
    for host_scan in host_scans:
        for ip in host_scan.ips:
            ips_set.add(ip)
    try:
        await send_to_scan_service(
            vulnerability_scan=vulnerability_scan, ips=list(ips_set), session=session
        )
        vulnerability_scan.start_host_scan_at = datetime.utcnow()
    except Exception as e:
        vulnerability_scan.status = ScanStatusEnum.FAILED
        await session.commit()
        await session.refresh(vulnerability_scan)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Не удалось отправить задачу сканеру",
        )
    return vulnerability_scan


async def delete_vulnerability_scan(
    session: AsyncSession, vulnerability_scan: VulnerabilityScan
) -> VulnerabilityScan:
    await session.delete(vulnerability_scan)
    await session.commit()
    return vulnerability_scan


async def send_to_scan_service(
    vulnerability_scan: VulnerabilityScan,
    session: AsyncSession,
    ips: List[str],
    timeout=1,
):
    async with httpx.AsyncClient(timeout=timeout) as client:
        data = {
            "vulnerability_scan_id": vulnerability_scan.id,
            "ips": ips,
        }
        try:
            response = await client.post(settings.vulnerability_scan_service_url, json=data)
            vulnerability_scan.start_host_scan_at = datetime.utcnow()
            await session.commit()
            response.raise_for_status()
        except Exception as e:
            logger.info(f"Не удалось отправить vulnerability_scan на сканирование")


async def get_cve_by_id(session: AsyncSession, user: User, cve_id: int) -> CVE:
    cve = await session.get(CVE, cve_id)
    if not cve:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Сканирование хоста с ID ({cve_id}) не найдено",
        )
    if cve.user_id != user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Сканирование хоста не принадлежит пользователю",
        )
    return cve


async def get_cve_by_scan(
    session: AsyncSession,
    user: User,
    scan: VulnerabilityScan,
    page_size: int = 10,
    page_number: int = 1,
    search: str | None = None,
) -> CVEList:
    stmt = select(CVE).where(
        (CVE.vulnerability_scan_id == scan.id) & (CVE.user_id == user.id)
    )

    if search is not None:
        search = f"%{search}%"
        stmt = stmt.where(
            or_(
                func.lower(CVE.name).like(func.lower(search)),
                func.lower(CVE.ip).like(func.lower(search)),
            )
        )
    result: Result = await session.execute(stmt)
    cves = list(result.scalars().all())

    limit = page_size
    offset = (page_number - 1) * page_size
    response_cves = cves[offset : offset + limit]
    total_pages = ceil(len(cves) / page_size)
    cves_list = CVEList(
        cves=response_cves,
        total_pages=total_pages,
        current_page=page_number,
    )
    return cves_list


async def create_cves(
    session: AsyncSession,
    user_id: int,
    scan: VulnerabilityScan,
    cves_list_create: List[CVECreate],
):
    if scan.status == ScanStatusEnum.FAILED:
        raise ValueError
    stmt = delete(CVE).where(CVE.vulnerability_scan_id == scan.id)
    await session.execute(stmt)

    # Подготовка данных для вставки
    cves_data = [
        {
            "user_id": user_id,
            "vulnerability_scan_id": scan.id,
            "name": cve.name,
            "severity": cve.severity,
            "title": cve.title,
            "exploit": cve.exploit,
            "status": cve.status,
            "description": cve.description,
            "ip": cve.ip,
            "service": cve.service,
            "port": cve.port,
        }
        for cve in cves_list_create
    ]

    stmt = insert(CVE).values(cves_data)
    await session.execute(stmt)
    scan.updated_at = datetime.utcnow()
    scan.end_host_scan_at = datetime.utcnow()
    scan.status = ScanStatusEnum.DONE
    await session.commit()


async def delete_cve(session: AsyncSession, cve: CVE) -> CVE:
    await session.delete(cve)
    await session.commit()
    return cve


async def get_ai_by_cve_id(session: AsyncSession, user: User, cve_id: int):
    cve = await session.get(CVE, cve_id)
    if not cve:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Сканирование хоста с ID ({cve_id}) не найдено",
        )
    if cve.user_id != user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Сканирование хоста не принадлежит пользователю",
        )

    if cve.ai_answer:
        return {"answer": cve.ai_answer}

    async with httpx.AsyncClient(timeout=60*10) as client:
        try:
            response = await client.get(settings.ai_service_url + f"?cve_id={cve.name}")
            response.raise_for_status()
            answer = response.json()["message"]
            cve.ai_answer = answer
            await session.commit()
            return {"answer": answer}
        except TimeoutException:
            logger.error(f"Таймаут при запросе к AI серверу: {settings.ai_service_url}")
            raise HTTPException(
                status_code=504, detail="AI сервер не отвечает: превышен таймаут"
            )
        except RequestError as e:
            logger.error(f"Ошибка запроса к AI серверу: {e}")
            raise HTTPException(
                status_code=502, detail="Ошибка запроса к AI серверу"
            )
        except Exception as e:
            logger.exception(f"Не удалось получить ответ с AI сервера: {e}")
            raise HTTPException(
                status_code=500, detail="Не удалось получить ответ с AI сервера"
            )
